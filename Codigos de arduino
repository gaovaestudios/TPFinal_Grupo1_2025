// C++ code
//
//buzzer TMB1205
// https://chatgpt.com/?utm_source=google&utm_medium=paidsearch_brand&utm_campaign=GOOG_C_SEM_GBR_Core_CHT_BAU_ACQ_PER_MIX_ALL_LATAM_AR_ES_052925&utm_term=chatgpt&utm_content=185952781651&utm_ad=755154754261&utm_match=e&gad_source=1&gad_campaignid=22619982913&gclid=CjwKCAjw04HIBhB8EiwA8jGNbQTT1a0FeZxMtZnJW4umsKEglFdR_1mAFXnSQP9nXyLM9iYENE7-IxoCjmYQAvD_BwE
// 
int buzzer = 12; // Pin donde estÃ¡ conectado el buzzer

void setup() {
  pinMode(buzzer, OUTPUT);
}

void loop() {
  digitalWrite(buzzer, HIGH);  // Encender el buzzer
  delay(1000);                 // Esperar 1 segundo
  digitalWrite(buzzer, LOW);   // Apagar el buzzer
  delay(1000);                 // Esperar 1 segundo
}
void apagar(){
  for (int i=1,i<=13,i++){
    digitalWrite(i,LOW);}
}

//heartbeat 
//https://youtu.be/VZl9YEIYvu8
#define samp_siz 4
#define rise_threshold 5

int sensorPin = A0;
int buzzer = 12; // Pin donde estÃ¡ conectado el buzzer

void setup() {
  Serial.begin(9600);
  pinMode(buzzer, OUTPUT);
}

void loop() {
  float reads[samp_siz], sum;
  long int now, ptr;
  float last, reader, start;
  float first, second, third, before, print_value;
  bool rising = false;
  int rise_count = 0;
  int n;
  long int last_beat = 0;

  const unsigned long interval = 3000;  // mostrar BPM cada 3 segundos
  unsigned long lastPrint = 0;
  float lastBPM = 0;

  for (int i = 0; i < samp_siz; i++)
    reads[i] = 0;
  sum = 0;
  ptr = 0;

  while (1) {
    // --- Lectura promedio para eliminar ruido ---
    n = 0;
    start = millis();
    reader = 0.;
    do {
      reader += analogRead(sensorPin);
      n++;
      now = millis();
    } while (now < start + 20);
    reader /= n;

    // --- Promedio mÃ³vil ---
    sum -= reads[ptr];
    sum += reader;
    reads[ptr] = reader;
    last = sum / samp_siz;

    // --- DetecciÃ³n de subida (latido) ---
    if (last > before) {
      rise_count++;
      if (!rising && rise_count > rise_threshold) {
        rising = true;
        first = millis() - last_beat;
        last_beat = millis();

        // Calcular BPM instantÃ¡neo con promedio ponderado
        print_value = 60000. / (0.4 * first + 0.3 * second + 0.3 * third);
        third = second;
        second = first;

        // Guardar BPM si estÃ¡ dentro del rango vÃ¡lido
        if (print_value >= 40 && print_value <= 100) {
          lastBPM = print_value;
        }
      }
    } else {
      rising = false;
      rise_count = 0;
    }

    before = last;
    ptr++;
    ptr %= samp_siz;

    // --- Mostrar BPM cada 3 segundos ---
    if (millis() - lastPrint >= interval) {
      if (lastBPM > 0) {
        Serial.print("BPM: ");
        Serial.println(lastBPM);

        // ðŸ”Š Hacer sonar el buzzer una vez por cada dato de BPM
        tone(buzzer, 1000, 200);  // tono de 1000 Hz durante 200 ms
      } else {
        Serial.println("Esperando seÃ±al vÃ¡lida...");
      }
      lastPrint = millis();
    }
  }
}

// ðŸ”‡ FunciÃ³n para apagar todos los pines digitales (por si la necesitÃ¡s)
void apagar() {
  for (int i = 0; i <= 13; i++) {
    digitalWrite(i, LOW);
  }
}

// botnera 4x4 Matrix Membrane Keypad (#27899)
#include <Keypad.h>

const byte ROWS = 4; // 4 filas
const byte COLS = 4; // 4 columnas

// Mapa de las teclas
char keys[ROWS][COLS] = {
  {'1', '2', '3', 'A'},
  {'4', '5', '6', 'B'},
  {'7', '8', '9', 'C'},
  {'*', '0', '#', 'D'}
};

// Pines conectados al Arduino (ajustado a tus conexiones)
byte rowPins[ROWS] = {10, 9, 8, 7};  // Filas â†’ pines 10,9,8,7
byte colPins[COLS] = {6, 5, 4, 3};   // Columnas â†’ pines 6,5,4,3

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

void setup() {
  Serial.begin(9600);
  Serial.println("Probando Keypad 4x4...");
}

void loop() {
  char key = keypad.getKey();

  if (key) {
    Serial.print("Tecla presionada: ");
    Serial.println(key);
  }
}

//temperatura ky-028 digital temperature(el cheto) / ky-013 analog temp (el mas tranqui)
